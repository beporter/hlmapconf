#!/usr/bin/perl -w
#############################################################################
#                                                                           #
# hlmapconf.pl - A script to set custom configs for each map in an HL       #
#                mapcycle.                                                  #
#              - (C) 2002 Brian Porter  <beporter@users.sourceforge.net>    #
#              - Distributed under the GPL terms - see the docs for info    #
#              - http://hlmapconf.sourceforge.net                           #
#                                                                           #
#############################################################################
# CVS $Id$ #
#############################################################################


### DEVELOPMENT BOOKMARK CODES - Search for these to locate 'bookmarks'. ####

#DEFAULT# = Default variable values.
#CUSTOM#  = Variable set for development purposes.
#INC#     = Incomplete code sections.
#DEBUG#   = Debugging clauses in code.


### 'PREPROCESSOR' DIRECTIVES ###############################################

use strict;                # Requires us to declare all vars used
use IO::File;              # Use File IO module.
use Getopt::Std;           # Create vars from command line switches & args.
#use GetOpt::Long;          # Create vars from command line switches & args. #INC#
#use Shell;                 # Access cls or clear shell commands. #INC#


### GLOBAL DEVELOPMENT CONSTANTS ############################################

# Development constants - please don't mess with these
my $SCRIPT_NAME         = "HL-MapConf";
my $VERSION             = "0.90";
my $RELEASE_DATE        = "November 21, 2002";
my $AUTHOR_NAME         = "Brian Porter";
my $AUTHOR_EMAIL        = "beporter\@users.sourceforge.net";
my $HOME_PAGE           = "http://hlmapconf.sourceforge.net";


### GLOBAL VARIABLES ########################################################

# HLDS base directory name. Remember to use double slashes for Windows paths.
# IE: "C:\\Sierra\\Half-Life\\"
#my $hldsBaseDir         = "/usr/local/games/hlds_l/";  #DEFAULT#
my $hldsBaseDir         = "C:\\Games\\Half-Life\\";

# Mod name. Half-Life = 'valve/', CS = 'cstrike/' etc. Be sure to include a
# trailing slash (or double-backslash for Windows).
#my $modName             = "cstrike/";  #DEFAULT#
my $modName             = "cstrike\\";

# Maps directory inside your mod folder. Usually "maps/". Be sure to 
# include a trailing slash (or double-backslash for Windows).
#my $mapDir              = "maps/";  #DEFAULT#
my $mapDir              = "maps\\";

# Your server's mapcycle file name.
#my $mapcycleName        = "mapcycle.txt";  #DEFAULT#
my $mapcycleName        = "mapcycle.txt";

# Your server's server.cfg file name.
#my $serverConfigName    = "server.cfg";  #DEFAULT#
my $serverConfigName    = "server.cfg";

# Block comment for cfg's. Anything between the "EOD"s will be inserted at 
# the beginning of all .cfg's generated by this script. Remember that these
# will end up being comments in HL .cfg files, and need to be commented using
# the double back-slashes.
my $configBlockComment  = <<EOD;
// Generated by $SCRIPT_NAME v$VERSION
// Copyright $RELEASE_DATE $AUTHOR_NAME <$AUTHOR_EMAIL>
// Visit <$HOME_PAGE> for more information.
//
//   (Add your own comments here.)
EOD


### MAIN ####################################################################

my @mapList = ();           # List of map names from the mapcycle.
my $mapName = "";           # Current map's shortname.
my %cvars  = ();            # Current map's cvars as key => value pairs.
my %opts = ( "b" => 0,      # Batch cvar,value list
             "i" => 0,      # Interactive flag
             "m" => 0,      # Map list
             "o" => 0,      # Overwrite flag
             "q" => 0,      # Quick cvar list
             "t" => 0,      # Tk flag
             "v" => 0, );   # Version flag


getopts('b:im:oq:tv', \%opts);

if   ($opts{"i"}){ Mode_CmdInteractive(); }
elsif($opts{"q"}){ Mode_CmdQuick();       }
elsif($opts{"b"}){ Mode_CmdBatch();       }
elsif($opts{"t"}){ Mode_TkVisual();       }
else             { VersionAndUsage();     }


### SUBROUTINES #############################################################

#---------------------------------------------------------------------------#
sub Mode_CmdInteractive
#INC#
{
  my $input = 0;            # Temp selection.
  my $input2 = 0;           # Temp selection.

  GetMapcycle();
  while(($input = MapMenu()) >= 0)
  {
  	$mapName = $mapList[$input];
  
  	GetConfig();
  	while($input = ConfigMenu())
  	{
  		print("\nPlease enter the value for $input");
      if(exists($cvars{$input}))
      {
      	print("\nThe current value is \"$cvars{$input}\"");
      }
      print("\nEntering a blank string will remove $input from this config: ");
  		$input2 = <>;
      chop($input2);               # Take off the newline at the end,
      $input2 =~ s/\r$//;          # as well as any DOS carriage returns,
  		SetConfig($input, $input2);
    }
    PutConfig();
  }
  print("\n\nThanks for playing!\n");
  HoldDOSBox();
}


#---------------------------------------------------------------------------#
sub Mode_CmdBatch
#INC#
{
  my $input = 0;            # Temp selection.
  my $input2 = 0;           # Temp selection.
  my $temp;                 # Temp var.

  GetMapcycle();

  # List of cvars & values from cmd line.
  my %cmdline_cvars = split(",", $opts{"c"});
  
  # List of files from cmd line to write to.  #INC#
  my @cmdline_files = $opts{"m"} ? split(",", $opts{"m"}) : @mapList;

  foreach $temp (@cmdline_files)
  {
  	$mapName = $temp;
    print("\n  $mapName: Reading...");
    GetConfig() unless $opts{"o"};  # Read old cfg file unless -o switch is set
  	
    print("Populating...");
    while(($input, $input2) = each(%cmdline_cvars))
    {
    	SetConfig($input, $input2);
    	print(".");
    }
  	
    print("Saving...");
    PutConfig();
  	
    print("Done.");
  }

  HoldDOSBox();
}


#---------------------------------------------------------------------------#
sub Mode_CmdQuick
#INC#
{
  my $input = 0;            # Temp selection.
  my $input2 = 0;           # Temp selection.
  my $temp;                 # Temp var.

  GetMapcycle();

  # cvars to prompt for values from cmd line.
  my @cmdline_cvars = split(",", $opts{"q"});
  
  # List of files from cmd line to write to. #INC#
  my @cmdline_files = $opts{"m"} ? split(",", $opts{"m"}) : @mapList;

  foreach $temp (@cmdline_files)
  {
  	$mapName = $temp;
    GetConfig() unless $opts{"o"};  # Read old cfg file unless -o switch is set
  	
    foreach $temp (@cmdline_cvars)
    {
      print("\n  $mapName: $temp");
      if(exists($cvars{$temp})){ print(" (currently \"$cvars{$temp}\") "); }
      print("= ");
      $input = <>;

      chop($input);               # Take off the newline at the end,
      $input =~ s/\r$//;          # as well as any DOS carriage returns,
      $input =~ s/^\s+//;         # No leading white..
      $input =~ s/\s+$//;         # ..or trailing white.

    	SetConfig($temp, $input);
    }
    PutConfig();
  }

  HoldDOSBox();
}


#---------------------------------------------------------------------------#
sub Mode_TkVisual
#INC#
{
  #INC#
  # Tk GUI commands
  print("\n\nTk Visual Mode currently unimplemented.\n\n");
}


#---------------------------------------------------------------------------#
sub MapMenu
#INC#
{
	my $input = 0;

  do
  {
  	print "\n\n0 - Exit\n\n";
    PrintMapcycle();
	  print "\nPlease enter the number of a map to edit: ";
    $input = <>;
  }while($input > $#mapList + 1 or $input < 0);

  return($input - 1);
}


#---------------------------------------------------------------------------#
sub ConfigMenu
#INC#
{
	my $input = 0;

  do
  {
  	print "\n\n0 - Return/Exit\n\n";
    PrintConfig();
	  print "\nPlease enter the name of a cvar to edit: ";
    $input = <>;
    chop $input;                # Take off the newline at the end,
    $input =~ s/\r$//;          # as well as any DOS carriage returns,
    $input =~ s/^\s+//;         # No leading white..
    $input =~ s/\s+$//;         # ..or trailing white.
    #print "input = " . $input; #DEBUG#
  }while(!$input and $input ne "0");

  return($input);
}


#---------------------------------------------------------------------------#
sub GetMapcycle
# Load the map names from the mapcycle into the @mapList array.
# PRECONDITION:
#   Global variables $hldsBaseDir, $modName, and $mapcycleName are correctly
#   set.
# POSTCONDITION:
#   @mapList contains one entry for each unique map shortname from
#   $mapcycleName.
{
  my $nextMap;
  my $element;
  my $alreadyExists;
  my $MAPCYC = new IO::File;

  if($MAPCYC->open("<" . $mapcycleName) ||
     $MAPCYC->open("<" . $hldsBaseDir . $modName . $mapcycleName))
  {
    while($nextMap = $MAPCYC->getline)
    {
      chop($nextMap);               # Take off the newline at the end,
      $nextMap =~ s/\r$//;          # as well as any DOS carriage returns,
      next unless length($nextMap); # or blank lines.

      #print $nextMap . "\n";   #DEBUG#

      # See if the map is in the cycle already..
      $alreadyExists = 0;
      foreach $element (@mapList)
      {
      	#print "element = $element, nextMap = $nextMap\n";  #DEBUG#
        if($nextMap eq $element)
      	{
      	  $alreadyExists = 1;
        }
      }

      # ..if not add it to the array.
      if(!$alreadyExists)
      {
      	push(@mapList, $nextMap);
      }
    }
    $MAPCYC->close;
  }
  else
  {
  	die("Sorry, Couldn't read the mapcycle \"" . $mapcycleName . "\": $!\n");
  }
}


#---------------------------------------------------------------------------#
sub PrintMapcycle
# Prints the mapcycle to STDOUT for user inspection.
# PRECONDITION:
#   $mapName contains a valid map shortname.
# POSTCONDITION:
#   @mapList has been printed to STDOUT for user inspection.
{
  my $element;
  my $count = 1;
  my $sep = "-";

# Nice way to do it, but makes syntax colors screwy.
# format STDOUT =
# @# @<@<<<<<<<<<<<<<<<<<<<<<
# $count, $sep, $element,
# .

# Ugly way to do it, but works fine and doesn't mess up syntax highlighting.
	foreach $element (@mapList)
  {
#   	write;
#   	$count++;
  	print($count++ . " " . $sep . " " . $element . "\n");
  }
}


#---------------------------------------------------------------------------#
sub GetConfig
# Reads the config file associated with the currently selected map and loads
# any values found into the %cvars hash.
# PRECONDITION:
#   $mapName contains the shortname (cs_mymap) of the current map.
# POSTCONDITION:
#   %cvars contains keys and values loaded from cs_mymap.cfg if it exists,
#   or remains empty if it does not.
{
  my $extension = ".cfg";         # Filename extension for config file.
  my $var;                        # cvar name in .cfg
  my $value;                      # Value of cvar in .cfg
  my $current;
  my $CFG = new IO::File;

  #print("in GetConfig() mapName= $mapName");   #DEBUG#

  if($CFG->open("<" . $mapName . $extension) ||
     $CFG->open("<" . $hldsBaseDir . $modName . $mapName . $extension))
  {
    %cvars = ();                  # Clear the %cvars hash of old key-vals first!
    while($current = $CFG->getline)
    {
      chomp($current);            # No newline.
      $current =~ s/\/\/.*//;     # No comments.
      $current =~ s/^\s+//;       # No leading white..
      $current =~ s/\s+$//;       # ..or trailing white.
      next unless length($current); # Don't continue unless there's something left.
      ($var, $value) = split(/\s* \s*/, $current, 2);
      $value =~ s/^\"//;          # Strip quotes from beginning..
      $value =~ s/\"$//;          # ..and end of values
      $cvars{$var} = $value;      # Load the untainted value into hash of cvars.
    }
    $CFG->close;
  }
  else
  {
  	print("Sorry, Couldn't read the config file");
    print(" \"" . $mapName . ".cfg\": $!\n");
  }
}


#---------------------------------------------------------------------------#
sub PrintConfig
# Prints the cvars (in %cvars) loaded for the current map to STDOUT.
# PRECONDITION:
#   $mapName contains a valid map shortname, and %cvars is loaded with that
#   map's current cfg variables.
# POSTCONDITION:
#   %cvars has been printed to STDOUT in "key => value" pairs for
#   user inspection.
{
  my $key;
  my $val;
  my $sep = "=";

# Nice way to do it, but makes syntax colors screwy.
# format STDOUT =
# @>>>>>>>>>>>>>>>>>>>>>> @ @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# $key, $sep, $val,
# .

	while( ($key, $val) = each(%cvars) )
	{
#     write;

# Ugly way to do it, but works fine and doesn't mess up syntax highlighting.
    print($key . " " . $sep . " " . $val . "\n");

  }
}
    

#---------------------------------------------------------------------------#
sub SetConfig #($cvar_key, $cvar_value)
# Modify, add or remove the cvars loaded for the current map. Takes two
# arguments: a string containing the name of a cvar, and a string containing
# the new value of the cvar. Passing the empty string "" in $cvar_value
# will cause the entry for $cvar_key to be deleted from the %cvars hash.
# PRECONDITION:
#   $mapName contains a valid map shortname, and %cvars is loaded with that
#   map's current cfg variables.
# POSTCONDITION:
#   %cvars has been updated to reflect user's changes to cfg variables.
{
  my $cvar_key;
  my $cvar_value;
  ($cvar_key, $cvar_value) = @_;

  if(defined($cvar_value))           # A value has been passed,
  {
    $cvars{$cvar_key} = $cvar_value; # ..create or update the cvar & value,
  }
  elsif(exists($cvars{$cvar_key}))   # make sure the key exists,
  {
  	delete($cvars{$cvar_key});       # ..remove it from the hash.
  }
}
    

#---------------------------------------------------------------------------#
sub PutConfig
# Writes cvars loaded for the current map to the appropriate .cfg file.
# PRECONDITION:
#   $mapName contains a valid map shortname, and %cvars is loaded with that
#   map's current cfg variables.
# POSTCONDITION:
#   A file named $mapName.cfg has been created (if previously non-existant), 
#   overwritten (if previously present), or deleted (if %cvars is empty) to
#   reflect the contents of the %cvars hash.
{
  my $key;
  my $val;
  my $extension = ".cfg";         # Filename extension for config file.
  my $CFG = new IO::File;

  if($CFG->open(">" . $hldsBaseDir . $modName . $mapName . $extension) ||
     $CFG->open(">" . $mapName . $extension))
  {
    # Write block comment
  	$CFG->print($configBlockComment . "\n\n");
  
    while( ($key, $val) = each(%cvars) )
  	{
  		# Write cvars
  		$CFG->print($key . " \"" . $val . "\"\n");
    }
    $CFG->close;
  }
  else
  {
  	print("Sorry, Couldn't write the config file");
    print(" \"" . $mapName . ".cfg\": $!\n");
  }
}


#---------------------------------------------------------------------------#
sub VersionAndUsage
# Prints the version and usage message.
{
  my $usageBlock = <<EOD;

${SCRIPT_NAME} v${VERSION}  <${HOME_PAGE}>
Copyright ${RELEASE_DATE} by ${AUTHOR_NAME} <${AUTHOR_EMAIL}>

Usage:
  hlmapconf.pl [-v|i|t]
  hlmapconf.pl [-o] [-m mapname[,mapname]] -b cvar,value[,cvar,value]
  hlmapconf.pl [-o] [-m mapname[,mapname]] -q cvar[,cvar]

Summary:
  HL-MapConf is small Perl script that allows Half-Life server admins to 
  create, modify and maintain custom config files for each map in a server's 
  mapcycle.

Switches:
  -b  ~ [B]atch Mode. Designates a cvar,value[,cvar,value] list.  #INC#
  -i  ~ [I]nteractive Mode. (Command Line)
  -m  ~ For use with Batch and Quick Modes. Designates a comma seperated list
        of [m]ap names for which to create cfg files.  #INC#
  -o  ~ For use with Batch and Quick Modes. Tells the script to [o]verwrite 
        any pre-existing config files instead of appending to them (which is 
        the default behavior).
  -q  ~ [Q]uick Mode. Designates a cvar[,cvar] list.  #INC#
  -t  ~ [T]k Visual Mode. (Requires the Tk Perl module!) See docs or search
        CPAN.org for more info.
  -v  ~ [V]ersion and Usage info. (Displays this message.)

Comments:
  Interactive, Tk, Batch, Quick and Version Modes are exclusive. Order of 
  precedence is i,q,b,t,v. To use Interactive Mode, specify -i. To use Tk 
  Visual Mode, specify -t. To use Batch Mode, specify -b and (optionally) -m
  with valid arguments. To use Quick Mode, specify -q and (optionally) -m with
  valid arguments. You may also specify the -o switch with Batch and Quick 
  Modes to overwrite any existing config files instead of appending the cvars 
  in the -b or -q switch to those that already exist in the .cfg files.

  Lastly, see the accompanying README.txt or visit $HOME_PAGE 
  for more details.

EOD

  print($usageBlock);
}


#---------------------------------------------------------------------------#
sub HoldDOSBox
# Holds a DOS box open if the OS type contains "win".
{
	#print $^O;   #DEBUG#
	if($^O =~ m/win/i)
	{
  	print "\nPress [ENTER] to close..";
  	<>
  }
}


#---------------------------------------------------------------------------#
sub ClearScreen  #INC#
# Call a shell specific clear-screen command.
{
	#print $^O;   #DEBUG#
	if($^O =~ m/win/i)
	{
		#print "calling cls";  #DEBUG#
    cls();
  }
  else
  {
  	clear();
  }
}

#---------------------------------------------------------------------------#
sub Tests  #DEBUG#
# Preforms debugging tests on various subroutines in this script. Assumes
# the global variables are set correctly.
{
	print "\n\nRunning Debugging tests::\n";
  
  # Hang on to current globals.
  print "\n\nStoring globals..\n";
  my @holder1 = @mapList;
  my $holder2 = $mapName;
  my %holder3 = %cvars;

  # Print the block comment to be embedded in cfg files.
  print "\n\nPrinting block comment:\n" . $configBlockComment;

  # Read mapcycle.txt and populate @mapList.
  print "\n\nMapcycle read and print test:\n";
  &GetMapcycle;
  &PrintMapcycle;

  # Test loading and printing of config files.
  print "\n\nConfig file read, print and write tests:\n";
  print "Reading server.cfg data..\n";
  $mapName = "server";
  &GetConfig;
  print "Printing server.cfg data..\n";
  &PrintConfig;
  print "Reading listenserver.cfg data..\n";
  $mapName = "listenserver";
  &GetConfig;
  print "Printing listenserver.cfg data..\n";
  &PrintConfig;
  print "Generating hlmc_test.cfg from above data..\n";
  $mapName = "hlmc_test";
  &PutConfig;

  # Restore globals to they're previous/default states.
  print "\n\nRestoring globals..\n";
  @mapList = @holder1;
  $mapName = $holder2;
  %cvars = %holder3;
  
  print "\nDone.\n\n";
}


#############################################################################
